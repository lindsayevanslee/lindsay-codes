{
  "hash": "ac0c3d2a588609914a6f27c7b8ff4606",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Analyze data from Apple's calendar\"\ndescription: \"New automation alert\"\ndate: \"2025-05-26\"\ndraft: false\nimage: apple_calendar_icon.png\nimage-alt: \"Apple Calendar logo, showing a square white calendar page a red header that reads JUL 17\"\ncategories: [calendar, python, github, automation]\njupyter: python3\nengine: knitr\nexecute:\n    eval: false\n---\n\n\n\nI regularly have to count up hours for different events in my calendar, which is a bit tedious. I thought it would be nice to automate this calculation, so with Claude's help, I wrote a Python script that reads the calendar data from Apple's Calendar app and counts up the hours for each event. I pushed this script to a GitHub repository and created a GitHub Actions workflow to run every week and display the totals in the Actions summary view. My GitHub repo for this is private, but I'll show the important pieces here. \n\nThe packages I use are as follows: \n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport caldav\nfrom datetime import datetime, timedelta\nimport pytz\nimport os\nfrom urllib.parse import quote\nimport logging\n```\n:::\n\n\n\nThe key package is `caldav`, which is what allows you to connect to the calendar.\n\nI set up a conda environment with the following `environment.yml` file:\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nname: calendar-automation\nchannels:\n  - conda-forge\n  - defaults\ndependencies:\n  - python=3.11\n  - pip=23.2.1\n  - caldav=1.3.9\n  - pytz=2025.2\n```\n:::\n\n\n\n\nI created a function to connect to the calendar as follows:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef connect_to_icloud_calendar():\n    \"\"\"Connect to iCloud calendar via CalDAV\"\"\"\n    \n    # Get credentials from environment variables\n    username = os.getenv('ICLOUD_USERNAME')  # your Apple ID\n    password = os.getenv('ICLOUD_APP_PASSWORD')  # App-specific password\n    \n    if not username or not password:\n        raise ValueError(\"Missing iCloud credentials. Set ICLOUD_USERNAME and ICLOUD_APP_PASSWORD environment variables.\")\n    \n    # iCloud CalDAV URL\n    url = f\"https://{quote(username)}:{quote(password)}@caldav.icloud.com\"\n    \n    try:\n        client = caldav.DAVClient(url)\n        principal = client.principal()\n        calendars = principal.calendars()\n        \n        if not calendars:\n            raise Exception(\"No calendars found\")\n            \n        print(f\"Connected to iCloud calendar successfully\")\n        return calendars\n        \n    except Exception as e:\n        print(f\"Failed to connect to iCloud calendar: {e}\")\n        raise\n```\n:::\n\n\n\nThis function depends on two environment variables: `ICLOUD_USERNAME` and `ICLOUD_APP_PASSWORD`. You can set these variables locally by running this after you have activated your conda environment:\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nexport ICLOUD_USERNAME=\"your-apple-id@email.com\"\nexport ICLOUD_APP_PASSWORD=\"your-app-specific-password\"\n```\n:::\n\n\n\nThe app-specific password can be generated by going to [appleid.apple.com](https://appleid.apple.com), logging in, going to the \"Sign-In and Security\" section, then clicking \"App-Specific Passwords\". Follow the instructions to generate an app-specific password. It'll only show it to you once. You may want to keep a note of it in a password manager so you can use it also for GitHub Actions.\n\nYou then connect to the calendar by calling the function:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncalendars = connect_to_icloud_calendar()\n```\n:::\n\n\n\nNext, I wrote a function to get the events from the calendar:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef get_work_week_events(calendars, event_name, start_date, end_date):\n    \"\"\"Get events within a date range\"\"\"\n    \n    print(f\"Searching for '{event_name}' events from {start_date.date()} ({start_date.strftime('%A')}) to {end_date.date()} ({end_date.strftime('%A')})\")\n    print(\"-\" * 60)\n    \n    matching_events = []\n    total_duration = timedelta(0)\n    \n    # Search through all calendars\n    for calendar in calendars:\n        try:\n            # Fetch events in date range\n            events = calendar.date_search(start=start_date, end=end_date)\n            \n            for event in events:\n                # Parse the event data\n                event_data = event.icalendar_component\n                \n                summary = str(event_data.get('SUMMARY', ''))\n                \n                # Check if event name matches (case insensitive)\n                if event_name.lower() not in summary.lower():\n                    continue\n                \n                # Get event times\n                start_time = event_data.get('DTSTART').dt\n                end_time = event_data.get('DTEND').dt\n                \n                # Handle all-day events (date objects vs datetime objects)\n                if hasattr(start_time, 'hour'):  # It's a datetime\n                    # Convert to UTC if needed\n                    if hasattr(start_time, 'tzinfo') and start_time.tzinfo:\n                        if start_time.tzinfo != pytz.UTC:\n                            start_time = start_time.astimezone(pytz.UTC)\n                    else:\n                        start_time = pytz.UTC.localize(start_time)\n                        \n                    if hasattr(end_time, 'tzinfo') and end_time.tzinfo:\n                        if end_time.tzinfo != pytz.UTC:\n                            end_time = end_time.astimezone(pytz.UTC)\n                    else:\n                        end_time = pytz.UTC.localize(end_time)\n                else:  # It's an all-day event (date object)\n                    # Convert date to datetime at start/end of day\n                    start_time = datetime.combine(start_time, datetime.min.time())\n                    end_time = datetime.combine(end_time, datetime.min.time())\n                    start_time = pytz.UTC.localize(start_time)\n                    end_time = pytz.UTC.localize(end_time)\n                \n                # Calculate duration\n                duration = end_time - start_time\n                \n                matching_events.append({\n                    'summary': summary,\n                    'start': start_time,\n                    'end': end_time,\n                    'duration': duration\n                })\n                total_duration += duration\n                \n        except Exception as e:\n            print(f\"Error processing calendar {calendar}: {e}\")\n            continue\n    \n    # Sort events by start time\n    matching_events.sort(key=lambda x: x['start'])\n    \n    return matching_events, total_duration\n```\n:::\n\n\n\nThis function takes the `calendars` data object, the name of the event to search for `event_name`, and a date range `start_date` and `end_date`. It returns a list of matching events and the total duration of those events. It is called like this:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nevents, total_duration = get_work_week_events(calendars, event_name, start_date, end_date)\n```\n:::\n\n\n\nNext I do some processing and formatting of the results, which print to the console when run locally.\n\nAfter confirming it all works as expected locally, I set up GitHub Actions by creating a workflow file at `.github/workflows/weekly-calendar-report.yml`:\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nname: Weekly Calendar Report\n\non:\n  schedule:\n    # Run every Sunday at 9 AM UTC \n    - cron: '0 9 * * 0'  # 0 = Sunday\n  workflow_dispatch: # Allow manual trigger for testing\n\njobs:\n  calendar-report:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n      \n    - name: Setup Conda Environment\n      uses: conda-incubator/setup-miniconda@v3\n      with:\n        environment-file: environment.yml\n        activate-environment: calendar-automation\n        python-version: 3.11\n        auto-activate-base: false\n        auto-update-conda: true\n\n    - name: Check conda environment\n      shell: bash -el {0}  # This ensures conda activation works\n      run: | \n        conda info\n        conda list\n        which python\n        python --version\n\n    - name: Generate Calendar Report\n      shell: bash -el {0}  \n      env:\n        ICLOUD_USERNAME: ${{ secrets.ICLOUD_USERNAME }}\n        ICLOUD_APP_PASSWORD: ${{ secrets.ICLOUD_APP_PASSWORD }}\n        EVENT_NAME: ${{ secrets.EVENT_NAME }}\n      run: |\n        echo \"=== WEEKLY CALENDAR REPORT ===\"\n        echo \"Generated: $(date)\"\n        echo \"Workflow Run: ${{ github.run_id }}\"\n        echo \"\"\n        echo \"Active conda environment: $CONDA_DEFAULT_ENV\"\n        \n        # Run the script and capture output\n        python calendar_report.py > calendar_output.txt 2>&1\n        \n        # Display in logs\n        cat calendar_output.txt\n        \n        # Add to GitHub workflow summary\n        echo \"## ðŸ“… Weekly Calendar Report\" >> $GITHUB_STEP_SUMMARY\n        echo \"**Generated:** $(date)\" >> $GITHUB_STEP_SUMMARY\n        echo \"\" >> $GITHUB_STEP_SUMMARY\n        echo \"### Calendar Output:\" >> $GITHUB_STEP_SUMMARY\n        echo '```' >> $GITHUB_STEP_SUMMARY\n        cat calendar_output.txt >> $GITHUB_STEP_SUMMARY\n        echo '```' >> $GITHUB_STEP_SUMMARY\n        \n        echo \"\"\n        echo \"=== END REPORT ===\"\n```\n:::\n\n\n\n\nIn the Generate Calendar Report step, I run the Python script `calendar_report.py` which contains all the code to connect to the calendar, find the right events, do the analyses, and print the results. The output is captured in a temp file `calendar_output.txt`, which is then displayed in the GitHub Actions logs and added to the workflow summary by `echo`ing the output to `$GITHUB_STEP_SUMMARY`.\n\nThe environmental variables `ICLOUD_USERNAME`, `ICLOUD_APP_PASSWORD`, and `EVENT_NAME` are set as GitHub Secrets, which you can configure in your repository settings under \"Settings\" -> \"Secrets and variables\" -> \"Actions\" -> \"Repository secrets\". `EVENT_NAME` is a pipe-delimited string of event names you want to search for, e.g. `Work|Meeting|Project`. In my full script I set it up where it searches for all event names included in this string.\n\nThat's it! Quite a bit of work to save me about 2 minutes each week, but it'll be worth it eventually.\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}