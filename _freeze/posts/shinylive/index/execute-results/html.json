{
  "hash": "b9cec57019b166b1466b277e01695213",
  "result": {
    "markdown": "---\ntitle: \"Going live with shinylive\"\ndescription: \"\"\ndate: \"2024-07-30\"\ndraft: true\nimage: shinylive-shinylive-deployment-model.png\nimage-alt: \"A diagram depicting how shinylive works from the documentation. The documenation says: When an application is deployed with Shinylive, Python and Shiny run in the web browser: the browser is effectively both the client and server for the application. There is a web server that serves files, but it does not run Python or Shiny—it can be a “dumb” static web server. Source: https://shiny.posit.co/py/docs/shinylive.html#deploying-shinylive-applications\"\ncategories: [shiny, web app]\njupyter: python3\nengine: knitr\nexecute:\n    eval: false\nfilters:\n  - shinylive\n---\n\n\nFollowing instructions here: https://github.com/quarto-ext/shinylive\n\nhttps://pypi.org/project/python-docx/\n\nhttps://shiny.posit.co/py/docs/shinylive.html#requiring-extra-packages-with-requirements.txt\n\nhttps://shinylive.io/py/examples/#extra-packages\n\nto get this to work in quarto need to create requirements.txt in the chunk: https://github.com/quarto-ext/shinylive/issues/5\n\nFollowed pattern in https://shinylive.io/py/examples/#file-download for how to create a document dynamically and get it to download, also refering to python-docx docs for info on how to use that package to create a document https://python-docx.readthedocs.io/en/latest/. testing in the examples play area was helpful (removing variables like, this rendering in quarto, the fact that I'm trying it locally and in github pages, etc)\n\n\nThis is a Shinylive application embedded in a Quarto doc.\n\n\n```{shinylive-python}\n#| standalone: true\n#| viewerHeight: 420\n\nimport io\nimport docx\nfrom shiny import App, render, ui\n\napp_ui = ui.page_fluid(\n    ui.input_slider(\"n\", \"How did the student do on the test?\", 0, 100, 40),\n    ui.download_button(\"download2\", \"Download\")\n)\n\ndef server(input, output, session):\n\n    @render.download(filename=\"file.docx\")\n    def download2():\n        #create document object\n        doc = docx.Document()\n\n        #add content to doc -------\n\n        #add a title\n        doc.add_heading('This is a report', 0)\n\n        #add a paragraph\n        p = doc.add_paragraph('A plain paragraph having some ')\n        p.add_run('bold').bold = True\n        p.add_run(' and some ')\n        p.add_run('italic.').italic = True\n\n        #add a heading\n        doc.add_heading('Results', level=1)\n\n        #add some lists\n        doc.add_paragraph(\n            'first item in unordered list', style='List Bullet'\n        )\n        doc.add_paragraph(\n            'first item in ordered list', style='List Number'\n        )\n        \n        #add a table, pulling from value inputted by user\n        records = (\n            (input.n(), 'Score 1', 'They did alright'),\n        )\n        \n        table = doc.add_table(rows=1, cols=3)\n        hdr_cells = table.rows[0].cells\n        hdr_cells[0].text = 'Score value'\n        hdr_cells[1].text = 'Score name'\n        hdr_cells[2].text = 'Interpretation'\n        \n        for qty, id, desc in records:\n            row_cells = table.add_row().cells\n            row_cells[0].text = str(qty)\n            row_cells[1].text = id\n            row_cells[2].text = desc\n\n        #add a page break\n        doc.add_page_break()\n\n\n        #save document ------------------\n        with io.BytesIO() as buf:\n            doc.save(buf)\n            yield buf.getvalue()\n\n\napp = App(app_ui, server)\n\n## file: requirements.txt\npython-docx\nlxml\n\n```\n\n\ndrawbacks: looks like for now shinylive in quarto needs to be one big code chunk\n\nfor data security reasons we may want to make something they can use and render locally, maybe electricShine can help? https://chasemc.github.io/electricShine/ or make some desktop app? https://www.r-bloggers.com/2014/04/deploying-desktop-apps-with-r/\n\nintersting tidbit learned: force a tuple of tuples by putting a comma at the end of tuple\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}